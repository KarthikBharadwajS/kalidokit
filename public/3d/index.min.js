function animate() { requestAnimationFrame(animate), currentVrm && currentVrm.update(clock.getDelta()), renderer.render(scene, orbitCamera) } const remap = Kalidokit.Utils.remap, clamp = Kalidokit.Utils.clamp, lerp = Kalidokit.Vector.lerp; let currentVrm; const renderer = new THREE.WebGLRenderer({ alpha: !0 }); renderer.setSize(window.innerWidth, window.innerHeight), renderer.setPixelRatio(window.devicePixelRatio), document.body.appendChild(renderer.domElement); const orbitCamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 1e3); orbitCamera.position.set(0, 1.4, .7); const orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement); orbitControls.screenSpacePanning = !0, orbitControls.target.set(0, 1.4, 0), orbitControls.update(); const scene = new THREE.Scene, light = new THREE.DirectionalLight(16777215); light.position.set(1, 1, 1).normalize(), scene.add(light); const clock = new THREE.Clock; animate(); const loader = new THREE.GLTFLoader; loader.crossOrigin = "anonymous", loader.load("https://cdn.glitch.com/29e07830-2317-4b15-a044-135e73c7f840%2FAshtra.vrm?v=1630342336981", e => { THREE.VRMUtils.removeUnnecessaryJoints(e.scene), THREE.VRM.from(e).then(e => { scene.add(e.scene), currentVrm = e, currentVrm.scene.rotation.y = Math.PI }) }, e => console.log("Loading model...", e.loaded / e.total * 100, "%"), e => console.error(e)); const rigRotation = (e, t = { x: 0, y: 0, z: 0 }, i = 1, r = .3) => { if (!currentVrm) return; const o = currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName[e]); if (!o) return; let n = new THREE.Euler(t.x * i, t.y * i, t.z * i, t.rotationOrder || "XYZ"), a = (new THREE.Quaternion).setFromEuler(n); o.quaternion.slerp(a, r) }, rigPosition = (e, t = { x: 0, y: 0, z: 0 }, i = 1, r = .3) => { if (!currentVrm) return; const o = currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName[e]); if (!o) return; let n = new THREE.Vector3(t.x * i, t.y * i, t.z * i); o.position.lerp(n, r) }; let oldLookTarget = new THREE.Euler; const rigFace = e => { if (!currentVrm) return; rigRotation("Neck", e.head, .7); const t = currentVrm.blendShapeProxy, i = THREE.VRMSchema.BlendShapePresetName; e.eye.l = lerp(clamp(1 - e.eye.l, 0, 1), t.getValue(i.Blink), .5), e.eye.r = lerp(clamp(1 - e.eye.r, 0, 1), t.getValue(i.Blink), .5), e.eye = Kalidokit.Face.stabilizeBlink(e.eye, e.head.y), t.setValue(i.Blink, e.eye.l), t.setValue(i.I, lerp(e.mouth.shape.I, t.getValue(i.I), .5)), t.setValue(i.A, lerp(e.mouth.shape.A, t.getValue(i.A), .5)), t.setValue(i.E, lerp(e.mouth.shape.E, t.getValue(i.E), .5)), t.setValue(i.O, lerp(e.mouth.shape.O, t.getValue(i.O), .5)), t.setValue(i.U, lerp(e.mouth.shape.U, t.getValue(i.U), .5)); let r = new THREE.Euler(lerp(oldLookTarget.x, e.pupil.y, .4), lerp(oldLookTarget.y, e.pupil.x, .4), 0, "XYZ"); oldLookTarget.copy(r), currentVrm.lookAt.applyer.lookAt(r) }, animateVRM = (e, t) => { if (!e) return; let i, r, o, n; const a = t.faceLandmarks, l = t.ea, d = t.poseLandmarks, s = t.rightHandLandmarks, m = t.leftHandLandmarks; a && (n = Kalidokit.Face.solve(a, { runtime: "mediapipe", video: videoElement }), rigFace(n)), d && l && (i = Kalidokit.Pose.solve(l, d, { runtime: "mediapipe", video: videoElement }), rigRotation("Hips", i.Hips.rotation, .7), rigPosition("Hips", { x: i.Hips.position.x, y: i.Hips.position.y + 1, z: -i.Hips.position.z }, 1, .07), rigRotation("Chest", i.Spine, .25, .3), rigRotation("Spine", i.Spine, .45, .3), rigRotation("RightUpperArm", i.RightUpperArm, 1, .3), rigRotation("RightLowerArm", i.RightLowerArm, 1, .3), rigRotation("LeftUpperArm", i.LeftUpperArm, 1, .3), rigRotation("LeftLowerArm", i.LeftLowerArm, 1, .3), rigRotation("LeftUpperLeg", i.LeftUpperLeg, 1, .3), rigRotation("LeftLowerLeg", i.LeftLowerLeg, 1, .3), rigRotation("RightUpperLeg", i.RightUpperLeg, 1, .3), rigRotation("RightLowerLeg", i.RightLowerLeg, 1, .3)), s && (r = Kalidokit.Hand.solve(s, "Left"), rigRotation("LeftHand", { z: i.LeftHand.z, y: r.LeftWrist.y, x: r.LeftWrist.x }), rigRotation("LeftRingProximal", r.LeftRingProximal), rigRotation("LeftRingIntermediate", r.LeftRingIntermediate), rigRotation("LeftRingDistal", r.LeftRingDistal), rigRotation("LeftIndexProximal", r.LeftIndexProximal), rigRotation("LeftIndexIntermediate", r.LeftIndexIntermediate), rigRotation("LeftIndexDistal", r.LeftIndexDistal), rigRotation("LeftMiddleProximal", r.LeftMiddleProximal), rigRotation("LeftMiddleIntermediate", r.LeftMiddleIntermediate), rigRotation("LeftMiddleDistal", r.LeftMiddleDistal), rigRotation("LeftThumbProximal", r.LeftThumbProximal), rigRotation("LeftThumbIntermediate", r.LeftThumbIntermediate), rigRotation("LeftThumbDistal", r.LeftThumbDistal), rigRotation("LeftLittleProximal", r.LeftLittleProximal), rigRotation("LeftLittleIntermediate", r.LeftLittleIntermediate), rigRotation("LeftLittleDistal", r.LeftLittleDistal)), m && (o = Kalidokit.Hand.solve(m, "Right"), rigRotation("RightHand", { z: i.RightHand.z, y: o.RightWrist.y, x: o.RightWrist.x }), rigRotation("RightRingProximal", o.RightRingProximal), rigRotation("RightRingIntermediate", o.RightRingIntermediate), rigRotation("RightRingDistal", o.RightRingDistal), rigRotation("RightIndexProximal", o.RightIndexProximal), rigRotation("RightIndexIntermediate", o.RightIndexIntermediate), rigRotation("RightIndexDistal", o.RightIndexDistal), rigRotation("RightMiddleProximal", o.RightMiddleProximal), rigRotation("RightMiddleIntermediate", o.RightMiddleIntermediate), rigRotation("RightMiddleDistal", o.RightMiddleDistal), rigRotation("RightThumbProximal", o.RightThumbProximal), rigRotation("RightThumbIntermediate", o.RightThumbIntermediate), rigRotation("RightThumbDistal", o.RightThumbDistal), rigRotation("RightLittleProximal", o.RightLittleProximal), rigRotation("RightLittleIntermediate", o.RightLittleIntermediate), rigRotation("RightLittleDistal", o.RightLittleDistal)) }; let videoElement = document.querySelector(".input_video"), guideCanvas = document.querySelector("canvas.guides"); const onResults = e => { drawResults(e), animateVRM(currentVrm, e) }, holistic = new Holistic({ locateFile: e => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/${e}` }); holistic.setOptions({ modelComplexity: 1, smoothLandmarks: !0, minDetectionConfidence: .7, minTrackingConfidence: .7, refineFaceLandmarks: !0 }), holistic.onResults(onResults); const drawResults = e => { guideCanvas.width = videoElement.videoWidth, guideCanvas.height = videoElement.videoHeight; let t = guideCanvas.getContext("2d"); t.save(), t.clearRect(0, 0, guideCanvas.width, guideCanvas.height), drawConnectors(t, e.poseLandmarks, POSE_CONNECTIONS, { color: "#00cff7", lineWidth: 4 }), drawLandmarks(t, e.poseLandmarks, { color: "#ff0364", lineWidth: 2 }), drawConnectors(t, e.faceLandmarks, FACEMESH_TESSELATION, { color: "#C0C0C070", lineWidth: 1 }), e.faceLandmarks && 478 === e.faceLandmarks.length && drawLandmarks(t, [e.faceLandmarks[468], e.faceLandmarks[473]], { color: "#ffe603", lineWidth: 2 }), drawConnectors(t, e.leftHandLandmarks, HAND_CONNECTIONS, { color: "#eb1064", lineWidth: 5 }), drawLandmarks(t, e.leftHandLandmarks, { color: "#00cff7", lineWidth: 2 }), drawConnectors(t, e.rightHandLandmarks, HAND_CONNECTIONS, { color: "#22c3e3", lineWidth: 5 }), drawLandmarks(t, e.rightHandLandmarks, { color: "#ff0364", lineWidth: 2 }) }, camera = new Camera(videoElement, { onFrame: async () => { await holistic.send({ image: videoElement }) }, width: 640, height: 480 }); camera.start();